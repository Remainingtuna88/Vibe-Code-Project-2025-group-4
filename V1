import React, { useState, useEffect, useRef } from 'react';

const EndlessRunner = () => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('menu'); // menu, playing, gameover
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(0);
  
  const gameRef = useRef({
    player: { x: 100, y: 300, width: 32, height: 32, velocityY: 0, isJumping: false },
    obstacles: [],
    powerups: [],
    ground: 350,
    speed: 5,
    gravity: 0.6,
    jumpForce: -12,
    frameCount: 0,
    invincible: false,
    invincibleTimer: 0
  });

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let animationId;

    const handleKeyPress = (e) => {
      if (gameState === 'menu' && e.code === 'Space') {
        startGame();
      } else if (gameState === 'playing' && e.code === 'Space') {
        jump();
      } else if (gameState === 'gameover' && e.code === 'Space') {
        startGame();
      }
    };

    const handleClick = () => {
      if (gameState === 'menu') {
        startGame();
      } else if (gameState === 'playing') {
        jump();
      } else if (gameState === 'gameover') {
        startGame();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    canvas.addEventListener('click', handleClick);

    const startGame = () => {
      const game = gameRef.current;
      game.player.y = 300;
      game.player.velocityY = 0;
      game.player.isJumping = false;
      game.obstacles = [];
      game.powerups = [];
      game.speed = 5;
      game.frameCount = 0;
      game.invincible = false;
      game.invincibleTimer = 0;
      setScore(0);
      setGameState('playing');
    };

    const jump = () => {
      const game = gameRef.current;
      if (!game.player.isJumping) {
        game.player.velocityY = game.jumpForce;
        game.player.isJumping = true;
      }
    };

    const drawPixelRect = (x, y, w, h, color) => {
      ctx.fillStyle = color;
      ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
    };

    const drawPlayer = () => {
      const game = gameRef.current;
      const p = game.player;
      
      // Body
      if (game.invincible) {
        const colors = ['#FFD700', '#FFA500', '#FF6347'];
        drawPixelRect(p.x, p.y, 32, 32, colors[Math.floor(game.frameCount / 5) % colors.length]);
      } else {
        drawPixelRect(p.x, p.y, 32, 32, '#FF6B6B');
      }
      
      // Eyes
      drawPixelRect(p.x + 8, p.y + 8, 6, 6, '#000');
      drawPixelRect(p.x + 18, p.y + 8, 6, 6, '#000');
      
      // Legs animation
      const legOffset = Math.floor(game.frameCount / 5) % 2 * 4;
      drawPixelRect(p.x + 6, p.y + 28, 8, 4, '#FF4757');
      drawPixelRect(p.x + 18, p.y + 28 + legOffset, 8, 4, '#FF4757');
    };

    const drawObstacle = (obs) => {
      // Cactus-like obstacle
      drawPixelRect(obs.x, obs.y, 24, 40, '#2ECC71');
      drawPixelRect(obs.x + 8, obs.y + 8, 8, 24, '#27AE60');
      drawPixelRect(obs.x, obs.y + 16, 8, 8, '#2ECC71');
      drawPixelRect(obs.x + 16, obs.y + 16, 8, 8, '#2ECC71');
    };

    const drawPowerup = (pu) => {
      const game = gameRef.current;
      const pulse = Math.sin(game.frameCount * 0.1) * 2;
      drawPixelRect(pu.x, pu.y + pulse, 20, 20, '#FFD700');
      drawPixelRect(pu.x + 4, pu.y + 4 + pulse, 12, 12, '#FFA500');
      drawPixelRect(pu.x + 8, pu.y + 8 + pulse, 4, 4, '#FF6347');
    };

    const drawGround = () => {
      const game = gameRef.current;
      drawPixelRect(0, game.ground, canvas.width, canvas.height - game.ground, '#8B4513');
      
      // Ground pattern
      for (let i = 0; i < canvas.width; i += 16) {
        const offset = (game.frameCount * game.speed) % 16;
        drawPixelRect(i - offset, game.ground, 8, 8, '#654321');
      }
    };

    const drawClouds = () => {
      const game = gameRef.current;
      for (let i = 0; i < 3; i++) {
        const x = ((game.frameCount * 2 + i * 200) % (canvas.width + 100)) - 50;
        const y = 50 + i * 40;
        drawPixelRect(x, y, 40, 16, '#ECF0F1');
        drawPixelRect(x + 8, y - 8, 24, 16, '#ECF0F1');
      }
    };

    const drawUI = () => {
      ctx.fillStyle = '#2C3E50';
      ctx.font = 'bold 20px monospace';
      ctx.fillText(`Score: ${score}`, 20, 30);
      
      if (gameRef.current.invincible) {
        const timeLeft = Math.ceil(gameRef.current.invincibleTimer / 60);
        ctx.fillStyle = '#FFD700';
        ctx.fillText(`Shield: ${timeLeft}s`, 20, 60);
      }
    };

    const update = () => {
      if (gameState !== 'playing') return;

      const game = gameRef.current;
      game.frameCount++;

      // Update player
      game.player.velocityY += game.gravity;
      game.player.y += game.player.velocityY;

      if (game.player.y >= game.ground - game.player.height) {
        game.player.y = game.ground - game.player.height;
        game.player.velocityY = 0;
        game.player.isJumping = false;
      }

      // Spawn obstacles
      if (game.frameCount % 90 === 0) {
        game.obstacles.push({
          x: canvas.width,
          y: game.ground - 40,
          width: 24,
          height: 40
        });
      }

      // Spawn powerups
      if (game.frameCount % 300 === 0 && Math.random() > 0.5) {
        game.powerups.push({
          x: canvas.width,
          y: game.ground - 120,
          width: 20,
          height: 20
        });
      }

      // Update obstacles
      game.obstacles = game.obstacles.filter(obs => {
        obs.x -= game.speed;
        
        // Collision detection
        if (!game.invincible &&
            game.player.x < obs.x + obs.width &&
            game.player.x + game.player.width > obs.x &&
            game.player.y < obs.y + obs.height &&
            game.player.y + game.player.height > obs.y) {
          setGameState('gameover');
          if (score > highScore) setHighScore(score);
          return false;
        }
        
        return obs.x > -obs.width;
      });

      // Update powerups
      game.powerups = game.powerups.filter(pu => {
        pu.x -= game.speed;
        
        // Collision detection for powerup
        if (game.player.x < pu.x + pu.width &&
            game.player.x + game.player.width > pu.x &&
            game.player.y < pu.y + pu.height &&
            game.player.y + game.player.height > pu.y) {
          game.invincible = true;
          game.invincibleTimer = 300; // 5 seconds at 60fps
          return false;
        }
        
        return pu.x > -pu.width;
      });

      // Update invincibility
      if (game.invincible) {
        game.invincibleTimer--;
        if (game.invincibleTimer <= 0) {
          game.invincible = false;
        }
      }

      // Increase difficulty
      if (game.frameCount % 300 === 0) {
        game.speed += 0.5;
      }

      // Update score
      setScore(Math.floor(game.frameCount / 10));
    };

    const draw = () => {
      // Clear canvas
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (gameState === 'menu') {
        drawClouds();
        drawGround();
        
        ctx.fillStyle = '#2C3E50';
        ctx.font = 'bold 48px monospace';
        ctx.fillText('PIXEL RUNNER', canvas.width / 2 - 180, canvas.height / 2 - 60);
        ctx.font = '24px monospace';
        ctx.fillText('Click or Press SPACE to Start', canvas.width / 2 - 180, canvas.height / 2);
        ctx.font = '20px monospace';
        ctx.fillText('Jump to avoid obstacles!', canvas.width / 2 - 130, canvas.height / 2 + 40);
        ctx.fillText('Collect shields for invincibility!', canvas.width / 2 - 180, canvas.height / 2 + 70);
        
      } else if (gameState === 'playing') {
        drawClouds();
        drawGround();
        
        gameRef.current.obstacles.forEach(drawObstacle);
        gameRef.current.powerups.forEach(drawPowerup);
        drawPlayer();
        drawUI();
        
      } else if (gameState === 'gameover') {
        drawClouds();
        drawGround();
        
        ctx.fillStyle = '#E74C3C';
        ctx.font = 'bold 48px monospace';
        ctx.fillText('GAME OVER', canvas.width / 2 - 150, canvas.height / 2 - 40);
        ctx.fillStyle = '#2C3E50';
        ctx.font = '24px monospace';
        ctx.fillText(`Score: ${score}`, canvas.width / 2 - 70, canvas.height / 2 + 10);
        ctx.fillText(`High Score: ${highScore}`, canvas.width / 2 - 100, canvas.height / 2 + 45);
        ctx.font = '20px monospace';
        ctx.fillText('Click or Press SPACE to Restart', canvas.width / 2 - 180, canvas.height / 2 + 90);
      }
    };

    const gameLoop = () => {
      update();
      draw();
      animationId = requestAnimationFrame(gameLoop);
    };

    gameLoop();

    return () => {
      window.removeEventListener('keydown', handleKeyPress);
      canvas.removeEventListener('click', handleClick);
      cancelAnimationFrame(animationId);
    };
  }, [gameState, score, highScore]);

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-900">
      <div className="text-center">
        <canvas
          ref={canvasRef}
          width={800}
          height={400}
          className="border-4 border-gray-700 rounded-lg shadow-2xl"
          style={{ imageRendering: 'pixelated' }}
        />
        <div className="mt-4 text-gray-400 text-sm">
          Click on the game or press SPACE to jump
        </div>
      </div>
    </div>
  );
};

export default EndlessRunner;
