<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Bit Endless Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Courier New', monospace;
        }
        
        .game-container {
            text-align: center;
        }
        
        canvas {
            border: 4px solid #0f3460;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .instructions {
            color: #94a3b8;
            margin-top: 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div class="instructions">Click on the game or press SPACE to jump â€” Portals will sometimes appear. Go through a portal to change the theme (jungle, snow, desert) with a flash effect.</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Ensure canvas draws crisp pixels for a 16-bit-style look
        ctx.imageSmoothingEnabled = false;
        
        // Game state
        let gameState = 'menu'; // menu, playing, gameover
        let score = 0;
        let highScore = 0;
        
        // Game object
        const game = {
            player: {
                x: 100,
                y: 300,
                width: 32,
                height: 32,
                velocityY: 0,
                isJumping: false
            },
            obstacles: [],
            powerups: [],
            ground: 350,
            speed: 5,
            gravity: 0.6,
            jumpForce: -12,
            frameCount: 0,
            invincible: false,
            invincibleTimer: 0
            ,
            // themes: default, jungle, snow, desert
            theme: 'default',
            themeColors: {
                default: {
                    sky: '#87CEEB',
                    ground: '#8B4513',
                    groundPattern: '#654321',
                    clouds: '#ECF0F1',
                    player: '#FF6B6B',
                    obstacle: '#2ECC71',
                    powerup: '#FFD700'
                },
                jungle: {
                    sky: '#88d498',
                    ground: '#3C7D3B',
                    groundPattern: '#2E6A2F',
                    clouds: '#D6F3D1',
                    player: '#FF7F50',
                    obstacle: '#2E8B57',
                    powerup: '#FFD700'
                },
                snow: {
                    sky: '#AEE3FF',
                    ground: '#F0F8FF',
                    groundPattern: '#DCEFF6',
                    clouds: '#FFFFFF',
                    player: '#72E0FF',
                    obstacle: '#8BB4D9',
                    powerup: '#FFFA87'
                },
                desert: {
                    sky: '#FFD89B',
                    ground: '#E8A34C',
                    groundPattern: '#D1863A',
                    clouds: '#FFF1D6',
                    player: '#FF8C42',
                    obstacle: '#C27C2C',
                    powerup: '#FFDD57'
                }
                ,
                space: {
                    sky: '#0b1220',
                    ground: '#1f2937',
                    groundPattern: '#111827',
                    clouds: '#111827',
                    player: '#9AE6FF',
                    obstacle: '#8A93A6',
                    powerup: '#FFD166'
                },
                city: {
                    sky: '#223344',
                    ground: '#2b2f36',
                    groundPattern: '#1e2228',
                    clouds: '#4B5563',
                    player: '#FFC857',
                    obstacle: '#9CA3AF',
                    powerup: '#FF6B6B'
                }
            },
            portals: [],
            backgroundObjects: [],
            // optional small particles for ambience (e.g., snow)
            bgParticles: [],
            // portal spawn configuration (frames interval and chance)
            portalConfig: {
                interval: 450, // lower = more frequent (frames)
                chance: 0.8,    // 0..1 chance when interval hits
                safeGap: 120,
                maxAttempts: 6
            },
            transition: {
                isActive: false,
                timer: 0,
                duration: 30, // frames
                nextTheme: null
            }
        };

        // Input handling
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'menu' || gameState === 'gameover') {
                    startGame();
                } else if (gameState === 'playing') {
                    jump();
                }
            }
        });

        canvas.addEventListener('click', () => {
            if (gameState === 'menu' || gameState === 'gameover') {
                startGame();
            } else if (gameState === 'playing') {
                jump();
            }
        });

        function startGame() {
            game.player.y = 300;
            game.player.velocityY = 0;
            game.player.isJumping = false;
            game.obstacles = [];
            game.powerups = [];
            game.backgroundObjects = [];
            game.bgParticles = [];
            populateBackground(game.theme);
            game.speed = 5;
            game.frameCount = 0;
            game.invincible = false;
            game.invincibleTimer = 0;
            score = 0;
            gameState = 'playing';
        }

        function jump() {
            if (!game.player.isJumping) {
                game.player.velocityY = game.jumpForce;
                game.player.isJumping = true;
            }
        }

        // Drawing functions
        function drawPixelRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
        }

        function drawPlayer() {
            const p = game.player;
            
            // Body - flashing colors when invincible
            if (game.invincible) {
                const colors = ['#FFD700', '#FFA500', '#FF6347'];
                const colorIndex = Math.floor(game.frameCount / 5) % colors.length;
                drawPixelRect(p.x, p.y, 32, 32, colors[colorIndex]);
            } else {
                drawPixelRect(p.x, p.y, 32, 32, game.themeColors[game.theme].player);
            }
            
            // Eyes
            drawPixelRect(p.x + 8, p.y + 8, 6, 6, '#000');
            drawPixelRect(p.x + 18, p.y + 8, 6, 6, '#000');
            
            // Legs animation
            const legOffset = Math.floor(game.frameCount / 5) % 2 * 4;
            // leg color matches a darker shade of player color
            const legColor = shadeColor(game.themeColors[game.theme].player, -20);
            drawPixelRect(p.x + 6, p.y + 28, 8, 4, legColor);
            drawPixelRect(p.x + 18, p.y + 28 + legOffset, 8, 4, legColor);
        }

        function drawObstacle(obs) {
            // Cactus-like obstacle
            drawPixelRect(obs.x, obs.y, 24, 40, game.themeColors[game.theme].obstacle);
            drawPixelRect(obs.x + 8, obs.y + 8, 8, 24, game.themeColors[game.theme].obstacle);
            drawPixelRect(obs.x, obs.y + 16, 8, 8, game.themeColors[game.theme].obstacle);
            drawPixelRect(obs.x + 16, obs.y + 16, 8, 8, game.themeColors[game.theme].obstacle);
        }

        function drawPowerup(pu) {
            const pulse = Math.sin(game.frameCount * 0.1) * 2;
            drawPixelRect(pu.x, pu.y + pulse, 20, 20, game.themeColors[game.theme].powerup);
            drawPixelRect(pu.x + 4, pu.y + 4 + pulse, 12, 12, '#FFA500');
            drawPixelRect(pu.x + 8, pu.y + 8 + pulse, 4, 4, '#FF6347');
        }

        function drawGround() {
            drawPixelRect(0, game.ground, canvas.width, canvas.height - game.ground, game.themeColors[game.theme].ground);
            
            // Ground pattern
            for (let i = 0; i < canvas.width; i += 16) {
                const offset = (game.frameCount * game.speed) % 16;
                drawPixelRect(i - offset, game.ground, 8, 8, game.themeColors[game.theme].groundPattern);
            }
        }

        function drawClouds() {
            for (let i = 0; i < 3; i++) {
                const x = ((game.frameCount * 2 + i * 200) % (canvas.width + 100)) - 50;
                const y = 50 + i * 40;
                drawPixelRect(x, y, 40, 16, game.themeColors[game.theme].clouds);
                drawPixelRect(x + 8, y - 8, 24, 16, game.themeColors[game.theme].clouds);
            }
        }

        // Populate background objects appropriate to a theme
        function populateBackground(theme) {
            game.backgroundObjects = [];
            const w = canvas.width;

            if (theme === 'jungle') {
                // tall trees, palms, vines, birds
                for (let i = 0; i < 8; i++) {
                    const x = i * (w / 6) + Math.random() * 120;
                    game.backgroundObjects.push({ type: 'tree', x, y: game.ground - 140, w: 80, h: 140, layer: 0.3, color: shadeColor(game.themeColors.jungle.ground, -10) });
                }
                for (let i = 0; i < 12; i++) {
                    const x = Math.random() * w;
                    game.backgroundObjects.push({ type: 'fern', x, y: game.ground - 28, w: 16, h: 28, layer: 0.8, color: shadeColor(game.themeColors.jungle.ground, -20) });
                }
                // add a few parrots
                for (let i = 0; i < 3; i++) {
                    const x = Math.random() * w;
                    const y = game.ground - 180 + Math.random() * 30;
                    game.backgroundObjects.push({ type: 'bird', x, y, w: 12, h: 8, layer: 0.25, color: '#FFCF33', vx: 0.8 + Math.random() * 0.6 });
                }
            } else if (theme === 'snow') {
                // pine trees and small cabins
                for (let i = 0; i < 10; i++) {
                    const x = i * (w / 6) + Math.random() * 80;
                    game.backgroundObjects.push({ type: 'pine', x, y: game.ground - 120, w: 40, h: 120, layer: 0.4, color: shadeColor(game.themeColors.snow.obstacle, -10) });
                }
                // cabins
                for (let i = 0; i < 2; i++) {
                    const x = Math.random() * w;
                    game.backgroundObjects.push({ type: 'cabin', x, y: game.ground - 60, w: 60, h: 48, layer: 0.6, color: '#A66F4B' });
                }
                // spawn initial snow particles
                for (let i = 0; i < 40; i++) game.bgParticles.push({ x: Math.random()*w, y: Math.random()*canvas.height, r: 1+Math.random()*2, speed: 0.5+Math.random()*1.5 });
            } else if (theme === 'desert') {
                // dunes: low shapes + scattered cacti
                for (let i = 0; i < 6; i++) {
                    const x = i * (w / 5) + Math.random() * 160;
                    game.backgroundObjects.push({ type: 'dune', x, y: game.ground - 60, w: 260, h: 60, layer: 0.35, color: shadeColor(game.themeColors.desert.ground, 6) });
                }
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * w;
                    game.backgroundObjects.push({ type: 'cactus', x, y: game.ground - 80, w: 18, h: 80, layer: 0.7, color: shadeColor(game.themeColors.desert.obstacle, -6) });
                }
            } else {
                // default: small hills and distant buildings
                for (let i = 0; i < 6; i++) {
                    const x = i * (w / 5) + Math.random() * 80;
                    game.backgroundObjects.push({ type: 'hill', x, y: game.ground - 60, w: 220, h: 60, layer: 0.3, color: shadeColor(game.themeColors.default.ground, -8) });
                }
                for (let i = 0; i < 6; i++) {
                    const x = Math.random() * w;
                    game.backgroundObjects.push({ type: 'building', x, y: game.ground - 120, w: 50, h: 120, layer: 0.2, color: '#3B4B5B' });
                }
            }

            // Space theme
            if (theme === 'space') {
                // starfield (handled by theme sky) plus planets and satellites
                for (let i = 0; i < 6; i++) {
                    const x = Math.random() * w;
                    const y = 40 + Math.random() * 120;
                    const size = 24 + Math.random() * 48;
                    game.backgroundObjects.push({ type: 'planet', x, y, w: size, h: size, layer: 0.15, color: '#8A63FF' });
                }
                for (let i = 0; i < 4; i++) {
                    const x = Math.random() * w;
                    const y = 20 + Math.random() * 200;
                    game.backgroundObjects.push({ type: 'satellite', x, y, w: 28, h: 12, layer: 0.25, color: '#C7D2FE', vx: -0.4 - Math.random()*0.8 });
                }
                // small asteroids nearer
                for (let i = 0; i < 12; i++) {
                    const x = Math.random() * w;
                    const y = 60 + Math.random() * 220;
                    game.backgroundObjects.push({ type: 'asteroid', x, y, w: 6+Math.random()*10, h: 6+Math.random()*10, layer: 0.45, color: '#9AA4B2', vx: -0.2 - Math.random()*0.6 });
                }
            }

            // City theme
            if (theme === 'city') {
                // skyscrapers and neon signs
                for (let i = 0; i < 12; i++) {
                    const x = i * (w / 10) + Math.random()*60;
                    const h = 80 + Math.random()*160;
                    game.backgroundObjects.push({ type: 'skyscraper', x, y: game.ground - h, w: 60, h, layer: 0.2, color: shadeColor(game.themeColors.city.obstacle, -10) });
                }
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * w;
                    const y = game.ground - 40 - Math.random()*60;
                    game.backgroundObjects.push({ type: 'neon', x, y, w: 40, h: 12, layer: 0.35, color: ['#FF6B6B','#FFD166','#6BCB77'][Math.floor(Math.random()*3)], vx: -0.3 - Math.random()*0.6 });
                }
                // occasional flying car/ship in the sky
                for (let i = 0; i < 3; i++) {
                    const x = Math.random() * w;
                    const y = 80 + Math.random()*120;
                    game.backgroundObjects.push({ type: 'flying', x, y, w: 36, h: 12, layer: 0.25, color: '#FCA311', vx: -0.6 - Math.random()*0.8 });
                }
            }
        }

        function updateBackgroundObjects() {
            for (let obj of game.backgroundObjects) {
                // parallax movement relative to game speed
                obj.x -= game.speed * obj.layer;
                // moving birds
                if (obj.type === 'bird') obj.x += obj.vx;
            }
            // wrap objects that move off left edge
            game.backgroundObjects = game.backgroundObjects.map(obj => {
                if (obj.x + (obj.w||40) < -50) {
                    obj.x = canvas.width + Math.random()*200;
                    // small random y variation
                    obj.y += (Math.random()-0.5)*20;
                }
                return obj;
            });

            // update bg particles (snow)
            game.bgParticles = game.bgParticles.filter(p => {
                p.y += p.speed;
                p.x += Math.sin((game.frameCount + p.x) * 0.01) * 0.2;
                return p.y < canvas.height + 20;
            });
            // spawn occasional new ones for snow
            if (game.theme === 'snow' && game.frameCount % 6 === 0) {
                game.bgParticles.push({ x: Math.random()*canvas.width, y: -6, r: 1+Math.random()*2, speed: 0.6+Math.random()*1.6 });
            }
        }

        function drawBackgroundObjects() {
            for (let obj of game.backgroundObjects) {
                ctx.save();
                // use simple pixel blocks to keep 16-bit spritey style
                if (obj.type === 'tree') {
                    // trunk
                    drawPixelRect(obj.x + obj.w/2 - 8, obj.y + obj.h - 40, 16, 40, shadeColor(obj.color, -30));
                    // canopy blocks
                    for (let yy = 0; yy < 4; yy++) {
                        drawPixelRect(obj.x + 8, obj.y + yy*28, obj.w-16, 24, obj.color);
                    }
                } else if (obj.type === 'fern') {
                    drawPixelRect(obj.x, obj.y, obj.w, obj.h, obj.color);
                } else if (obj.type === 'bird') {
                    drawPixelRect(obj.x, obj.y, obj.w, obj.h, obj.color);
                    drawPixelRect(obj.x + 6, obj.y+1, 4, 2, '#D94A4A');
                    // slight flap movement
                    obj.y += Math.sin(game.frameCount*0.08 + obj.x)*0.2;
                } else if (obj.type === 'pine') {
                    // layered triangle look using rectangles for pixel style
                    for (let i=0;i<4;i++) drawPixelRect(obj.x + 10 - i*6, obj.y + i*24, obj.w - (i*12), 20, obj.color);
                    drawPixelRect(obj.x + obj.w/2 - 6, obj.y + obj.h - 20, 12, 20, shadeColor(obj.color, -30));
                } else if (obj.type === 'cabin') {
                    drawPixelRect(obj.x, obj.y, obj.w, obj.h, obj.color);
                    drawPixelRect(obj.x + 6, obj.y + 6, obj.w - 12, obj.h - 12, '#FFD9B6');
                } else if (obj.type === 'dune' || obj.type === 'hill') {
                    // curved block using multiple rectangles for layered dunes
                    for (let i=0;i<4;i++) drawPixelRect(obj.x + i*20, obj.y + i*8, obj.w - i*40, obj.h - i*8, obj.color);
                } else if (obj.type === 'cactus') {
                    drawPixelRect(obj.x, obj.y, obj.w, obj.h, obj.color);
                    drawPixelRect(obj.x - 8, obj.y + 20, 8, 12, obj.color);
                    drawPixelRect(obj.x + obj.w, obj.y + 28, 8, 12, obj.color);
                } else if (obj.type === 'planet') {
                    // paint a blocky planet (approx circle with rectangles)
                    const s = Math.floor(obj.w/2);
                    drawPixelRect(obj.x - s/2, obj.y - s/2, s*2, s*2, obj.color);
                    drawPixelRect(obj.x - s/2 + 4, obj.y - s/2 + 4, s, s, shadeColor(obj.color, 10));
                } else if (obj.type === 'satellite') {
                    drawPixelRect(obj.x, obj.y, obj.w, obj.h, obj.color);
                    // little antenna
                    drawPixelRect(obj.x + obj.w - 4, obj.y - 4, 2, 4, '#FFF');
                } else if (obj.type === 'asteroid') {
                    drawPixelRect(obj.x, obj.y, obj.w, obj.h, obj.color);
                } else if (obj.type === 'skyscraper') {
                    drawPixelRect(obj.x, obj.y, obj.w, obj.h, obj.color);
                    // windows pattern
                    for (let yy = obj.y + 8; yy < obj.y + obj.h - 8; yy += 14) {
                        for (let xx = obj.x + 6; xx < obj.x + obj.w - 6; xx += 12) {
                            drawPixelRect(xx, yy, 6, 8, '#E6EEF6');
                        }
                    }
                } else if (obj.type === 'neon') {
                    drawPixelRect(obj.x, obj.y, obj.w, obj.h, obj.color);
                } else if (obj.type === 'flying') {
                    drawPixelRect(obj.x, obj.y, obj.w, obj.h, obj.color);
                    drawPixelRect(obj.x + 4, obj.y + 2, obj.w - 8, 3, '#222');
                } else if (obj.type === 'building') {
                    drawPixelRect(obj.x, obj.y, obj.w, obj.h, obj.color);
                    // windows
                    for (let yy = obj.y + 10; yy < obj.y + obj.h - 10; yy += 18) {
                        for (let xx = obj.x + 6; xx < obj.x + obj.w - 6; xx += 14) {
                            drawPixelRect(xx, yy, 6, 8, '#F1F6F9');
                        }
                    }
                }
                ctx.restore();
            }
            // draw bg particles (snow)
            if (game.bgParticles.length) {
                ctx.fillStyle = '#FFF';
                for (let p of game.bgParticles) ctx.fillRect(Math.floor(p.x), Math.floor(p.y), Math.ceil(p.r), Math.ceil(p.r));
            }
        }
        // Utility: shade a hex color by percent (-100 to 100)
        function shadeColor(hex, percent) {
            const f = hex.slice(1);
            const R = parseInt(f.substring(0,2),16);
            const G = parseInt(f.substring(2,4),16);
            const B = parseInt(f.substring(4,6),16);
            const t = percent < 0 ? 0 : 255;
            const p = Math.abs(percent)/100;
            const newR = Math.round((t - R) * p) + R;
            const newG = Math.round((t - G) * p) + G;
            const newB = Math.round((t - B) * p) + B;
            return `#${(newR.toString(16)).padStart(2,'0')}${(newG.toString(16)).padStart(2,'0')}${(newB.toString(16)).padStart(2,'0')}`;
        }

        function drawUI() {
            ctx.fillStyle = '#2C3E50';
            ctx.font = 'bold 20px monospace';
            ctx.fillText('Score: ' + score, 20, 30);
            
            if (game.invincible) {
                const timeLeft = Math.ceil(game.invincibleTimer / 60);
                ctx.fillStyle = '#FFD700';
                ctx.fillText('Shield: ' + timeLeft + 's', 20, 60);
            }

            ctx.fillStyle = '#2C3E50';
            ctx.font = 'bold 16px monospace';
            ctx.fillText('Theme: ' + game.theme, canvas.width - 160, 30);
        }

        // Portal visuals - circular ring with swirling pixels
        function drawPortal(portal) {
            const w = portal.width;
            const h = portal.height;
            const cx = portal.x + w/2;
            const cy = portal.y + h/2;

            // Outer ring
            drawPixelRect(portal.x, portal.y, w, h, '#4B0082');
            // inner void
            drawPixelRect(portal.x + 6, portal.y + 6, w - 12, h - 12, '#000');

            // swirl animation
            for (let i = 0; i < 6; i++) {
                const angle = (game.frameCount * 0.08 + i) % 6.28;
                const px = Math.floor(cx + Math.cos(angle) * (w/4));
                const py = Math.floor(cy + Math.sin(angle) * (h/4));
                drawPixelRect(px, py, 4, 4, portal.color);
            }
        }

        // Game logic
        function update() {
            if (gameState !== 'playing') return;

            game.frameCount++;

            // update background objects and particles (parallax)
            updateBackgroundObjects();

            // Update player
            game.player.velocityY += game.gravity;
            game.player.y += game.player.velocityY;

            if (game.player.y >= game.ground - game.player.height) {
                game.player.y = game.ground - game.player.height;
                game.player.velocityY = 0;
                game.player.isJumping = false;
            }

            // Spawn obstacles
            if (game.frameCount % 90 === 0) {
                game.obstacles.push({
                    x: canvas.width,
                    y: game.ground - 40,
                    width: 24,
                    height: 40
                });
            }

            // Spawn powerups
            if (game.frameCount % 300 === 0 && Math.random() > 0.5) {
                game.powerups.push({
                    x: canvas.width,
                    y: game.ground - 120,
                    width: 20,
                    height: 20
                });
            }

            // Spawn portals according to portalConfig and avoid overlapping obstacles
            if (game.frameCount % game.portalConfig.interval === 0 && Math.random() < game.portalConfig.chance) {
                // choose a random theme that's not current
                const possible = Object.keys(game.themeColors).filter(t => t !== game.theme);
                const nextTheme = possible[Math.floor(Math.random()*possible.length)];

                // find a horizontal spawn X that is not too close to any existing obstacle
                let spawnX = canvas.width;
                const safeGap = game.portalConfig.safeGap; // px gap from nearest obstacle
                // check nearest obstacle (those recently spawned will be around canvas.width)
                const tooClose = game.obstacles.some(obs => Math.abs(obs.x - spawnX) < safeGap);
                if (tooClose) {
                    // push spawn further to the right until it's safe
                    let attempts = 0;
                    while (attempts < game.portalConfig.maxAttempts) {
                        spawnX += safeGap + Math.random()*80;
                        if (!game.obstacles.some(obs => Math.abs(obs.x - spawnX) < safeGap)) break;
                        attempts++;
                    }
                }

                game.portals.push({
                    x: spawnX,
                    y: game.ground - 96,
                    width: 48,
                    height: 64,
                    color: game.themeColors[nextTheme].player,
                    targetTheme: nextTheme
                });
            }

            // Update obstacles
            game.obstacles = game.obstacles.filter(obs => {
                obs.x -= game.speed;
                
                // Collision detection
                if (!game.invincible &&
                    game.player.x < obs.x + obs.width &&
                    game.player.x + game.player.width > obs.x &&
                    game.player.y < obs.y + obs.height &&
                    game.player.y + game.player.height > obs.y) {
                    gameState = 'gameover';
                    if (score > highScore) {
                        highScore = score;
                    }
                    return false;
                }
                
                return obs.x > -obs.width;
            });

            // Update powerups
            game.powerups = game.powerups.filter(pu => {
                pu.x -= game.speed;
                
                // Collision detection for powerup
                if (game.player.x < pu.x + pu.width &&
                    game.player.x + game.player.width > pu.x &&
                    game.player.y < pu.y + pu.height &&
                    game.player.y + game.player.height > pu.y) {
                    game.invincible = true;
                    game.invincibleTimer = 300; // 5 seconds at 60fps
                    return false;
                }
                
                return pu.x > -pu.width;
            });

            // Update invincibility
            if (game.invincible) {
                game.invincibleTimer--;
                if (game.invincibleTimer <= 0) {
                    game.invincible = false;
                }
            }

            // Increase difficulty
            if (game.frameCount % 300 === 0) {
                game.speed += 0.5;
            }

            // Update score
            score = Math.floor(game.frameCount / 10);

            // Update portals
            game.portals = game.portals.filter(portal => {
                portal.x -= game.speed;

                if (!game.transition.isActive &&
                    game.player.x < portal.x + portal.width &&
                    game.player.x + game.player.width > portal.x &&
                    game.player.y < portal.y + portal.height &&
                    game.player.y + game.player.height > portal.y) {
                    // start transition
                    game.transition.isActive = true;
                    game.transition.timer = 0;
                    game.transition.nextTheme = portal.targetTheme;
                    return false; // remove portal immediately
                }

                return portal.x > -portal.width;
            });

            // handle transition timer
            if (game.transition.isActive) {
                game.transition.timer++;
                // When timer reaches mid-point, change theme
                if (game.transition.timer === Math.floor(game.transition.duration / 2)) {
                    game.theme = game.transition.nextTheme || 'default';
                    // repopulate background for the new theme
                    populateBackground(game.theme);
                }
                if (game.transition.timer >= game.transition.duration) {
                    game.transition.isActive = false;
                    game.transition.timer = 0;
                    game.transition.nextTheme = null;
                }
            }
        }

        function draw() {
            // Clear canvas with sky color depending on current theme
            ctx.fillStyle = game.themeColors[game.theme].sky;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'menu') {
                    drawBackgroundObjects();
                    drawClouds();
                    drawGround();
                
                ctx.fillStyle = '#2C3E50';
                ctx.font = 'bold 48px monospace';
                ctx.fillText('PIXEL RUNNER', canvas.width / 2 - 180, canvas.height / 2 - 60);
                ctx.font = '24px monospace';
                ctx.fillText('Click or Press SPACE to Start', canvas.width / 2 - 180, canvas.height / 2);
                ctx.font = '20px monospace';
                ctx.fillText('Jump to avoid obstacles!', canvas.width / 2 - 130, canvas.height / 2 + 40);
                ctx.fillText('Collect shields for invincibility!', canvas.width / 2 - 180, canvas.height / 2 + 70);
                
            } else if (gameState === 'playing') {
                drawBackgroundObjects();
                drawClouds();
                drawGround();
                
                game.obstacles.forEach(drawObstacle);
                game.powerups.forEach(drawPowerup);
                game.portals.forEach(drawPortal);
                drawPlayer();
                drawUI();

                // transition flash overlay
                if (game.transition.isActive) {
                    // alpha goes up to 0.9 then back
                    const half = Math.floor(game.transition.duration / 2);
                    let alpha = game.transition.timer <= half ? game.transition.timer / half : (game.transition.duration - game.transition.timer) / half;
                    alpha = Math.min(Math.max(alpha, 0), 1);
                    ctx.fillStyle = `rgba(255,255,255, ${alpha})`;
                    ctx.fillRect(0,0,canvas.width,canvas.height);
                }
                
            } else if (gameState === 'gameover') {
                drawClouds();
                drawGround();
                
                ctx.fillStyle = '#E74C3C';
                ctx.font = 'bold 48px monospace';
                ctx.fillText('GAME OVER', canvas.width / 2 - 150, canvas.height / 2 - 40);
                ctx.fillStyle = '#2C3E50';
                ctx.font = '24px monospace';
                ctx.fillText('Score: ' + score, canvas.width / 2 - 70, canvas.height / 2 + 10);
                ctx.fillText('High Score: ' + highScore, canvas.width / 2 - 100, canvas.height / 2 + 45);
                ctx.font = '20px monospace';
                ctx.fillText('Click or Press SPACE to Restart', canvas.width / 2 - 180, canvas.height / 2 + 90);
            }
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        gameLoop();
    </script>
</body>
</html>